/**
 * 
 * This file was automatically generated by the Repast Simphony Agent Editor.
 * Please see http://repast.sourceforge.net/ for details.
 * 
 */

/**
 *
 * Set the package name.
 *
 */
package suddenStop;

import static java.lang.Math.*;
import static repast.simphony.essentials.RepastEssentials.*;
import repast.simphony.context.Context;

/**
 * 
 * This is an agent.
 * 
 */
public class Firm {

	public static SupplyManager supplyManager;

	public class Decision {
		double quantity = 0.0;
		double rD = 0.0;
	}

	public Decision currentDecision = new Decision();

	public Decision nextDecision = new Decision();

	public class State {
		double acumQ = 0.0;
		// chequear firstUnitCost decía null
		double firstUnitCost = 0.0;
		double performance = 0.0;
		double capital = 0.0;
		double capitalProductivity = 1.0;
		double rDEfficiency = 0.0;
		double costOfCapital = 0.0;
		double fixedCost = 0.0;
		double profit = 0.0;
		double firmReturn = 0.0;
	}

	public State currentState = new State();

	protected static long agentIDCounter = 1;
	protected String agentID = "Firm " + (agentIDCounter++);

	public Firm(Context<Object> context) {
		
		
		context.add(this);
		
		born = GetTickCount();

		// A minimum FUC is set to 10% of mean
		currentState.firstUnitCost = max(
				0.1 * (Double) GetParameter("firstUnitCostMean"),
				supplyManager.firstUnitCostNormal.nextDouble());
		currentState.capitalProductivity = (Double) GetParameter("capitalProductivity");
		nextDecision.rD = 0.0;

		currentState.capital = max((Double) GetParameter("minimumCapital"),
				supplyManager.iniKNormal.nextDouble());
		nextDecision.quantity = currentState.capital
				* currentState.capitalProductivity;

		// 0.5 < learning rate <= 1.0
		double learningRate = min(1.0,
				max(supplyManager.learningRateDistrib.nextDouble(), 0.51));
		expon = log(learningRate) / log(2.0);
		currentState.rDEfficiency = max(0.0,
				supplyManager.rDEfficiencyNormal.nextDouble());

		currentState.costOfCapital = (Double) GetParameter("costOfCapital");
		currentState.fixedCost = (Double) GetParameter("fixedCost");
		currentState.performance = (Double) GetParameter("initialPerformance");

	}

	public double offer() {

		currentDecision.quantity = nextDecision.quantity;
		currentDecision.rD = nextDecision.rD;
		return currentDecision.quantity;

	}


	public double profit(State firmState, Decision decision, double price) {

		// Calculates cost using learning curve: cost of new acummulated Q minus
		// old acummulated Q. See http://maaw.info/LearningCurveSummary.htm
		// (Wright model)
		return price
				* decision.quantity
				- firmState.firstUnitCost
				* (pow(firmState.acumQ + decision.quantity, 1.0 + expon) - pow(
						firmState.acumQ, 1.0 + expon))
				- (firmState.costOfCapital + (Double) GetParameter("depreciation"))
				* firmState.capital - decision.rD - firmState.fixedCost;

	}

	/**
	 * 
	 * Process demand respond and returns false if firm exits the industry,
	 * otherwise returns true
	 * 
	 * @method processDemandResponse
	 * 
	 */
	public boolean processDemandResponse() {

		// Define the return value variable.
		boolean returnValue;

		// Calculates profit & Performance
		currentState.profit = profit(currentState, currentDecision,
				supplyManager.price);
		currentState.firmReturn = currentState.profit / currentState.capital;
		currentState.performance = (Double) GetParameter("performanceWeight")
				* currentState.performance
				+ (1 - (Double) GetParameter("performanceWeight"))
				* currentState.firmReturn;

		// if it is an exit, returns false
		returnValue = !(currentState.performance < (Double) GetParameter("minimumPerformance") || currentState.capital < (Double) GetParameter("minimumCapital"));

		currentState.acumQ += currentDecision.quantity;
		acumProfit += currentState.profit;

		medCost = (supplyManager.price * currentDecision.quantity - currentState.profit)
				/ currentDecision.quantity;
		varCost = (supplyManager.price * currentDecision.quantity
				- currentState.profit - currentDecision.rD - currentState.fixedCost)
				/ currentDecision.quantity;

		return returnValue;

	}

	public void plan() {

		double maxFunding = currentState.profit
				+ (Double) GetParameter("depreciation")
				* currentState.capital
				+ ((Demand.getSSMagnitude() > 0.0) ? 0.0
						: ((Double) GetParameter("maxExternalFunding") * currentState.capital));

		double invest = min(maxFunding, currentState.capital
				* ((Double) GetParameter("depreciation") + netInvestment()));

		invest = max(0.0, invest);

		currentState.capital = currentState.capital
				* (1.0 - (Double) GetParameter("depreciation")) + invest;

		nextDecision.quantity = currentState.capital
				* currentState.capitalProductivity;

		// Then new R&D is determined to optimize First unit cost.The maxFunding
		// is relevant to speed up the process.
		double optimalRD = pow(
				currentState.firstUnitCost
						/ currentState.rDEfficiency
						* (pow(currentState.acumQ + nextDecision.quantity,
								1.0 + expon) - pow(currentState.acumQ,
								1.0 + expon)), 0.5) - 1.0;

		double minRD = 1.0 / currentState.rDEfficiency - 1.0;

		nextDecision.rD = max(minRD, min(maxFunding - invest, optimalRD));

		// apply innovation
		currentState.firstUnitCost *= 1.0
				/ ((nextDecision.rD + 1.0) * currentState.rDEfficiency)
				* supplyManager.innovationErrorNormal.nextDouble();


	}

	public double marginalCost() {

		return currentState.firstUnitCost
				* (1.0 + expon)
				* pow(currentState.acumQ + currentDecision.quantity, expon)
				+ (currentState.costOfCapital + (Double) GetParameter("depreciation"))
				/ currentState.capitalProductivity;

	}

	public double netInvestment() {

		double optimalMarkUp = ((Double) GetParameter("demandElasticity") + (1 - marketShare())
				* (Double) GetParameter("supplyElasticity"))
				/ ((Double) GetParameter("demandElasticity")
						+ (1 - marketShare())
						* (Double) GetParameter("supplyElasticity") - marketShare());

		// dejo Winter a un lado y pongo el máximo igual al mark up del
		// substituto.
		/*
		 * double maxMarkUp = 0.999 (supplyManager.price + (Double)
		 * GetParameter("priceOfSubstitute")) / (2 * marginalCost()); return
		 * (Double) GetParameter("investmentParam") (1 - min(optimalMarkUp,
		 * maxMarkUp) * marginalCost() / supplyManager.price);
		 */
		return (Double) GetParameter("investmentParam")
				* (1 - optimalMarkUp * marginalCost() / supplyManager.price);

	}

	public double marketShare() {

		// Market Share is calculated with the quantity remaining after the dead
		// firms have exited the industry
		return currentDecision.quantity / supplyManager.totalQuantity;

	}

	public double price() {
		return supplyManager.price;
	}

	public double quantity() {
		return currentDecision.quantity;
	}

	public double Profit() {
		return currentState.profit;
	}

	public double performance() {
		return currentState.performance;
	}

	public double rD() {
		return currentDecision.rD;
	}

	public double getReturn() {
		return currentState.firmReturn;
	}

	public double getFirstUnitCost() {
		return currentState.firstUnitCost;
	}

	public double acumQuantity() {
		return currentState.acumQ;
	}

	public String toString() {
		return this.agentID;
	}

	public double getBorn() {
		return born;
	}

	public double born = 0.0;

	public double getExpon() {
		return expon;
	}

	public double expon = 0.0;

	public double getAcumProfit() {
		return acumProfit;
	}

	public double acumProfit = 0.0;

	public double getMedCost() {
		return medCost;
	}

	public double medCost = 0.0;

	public double getVarCost() {
		return varCost;
	}

	public double varCost = 0.0;

	public double age() {
		return GetTickCount() - born;
	}

}

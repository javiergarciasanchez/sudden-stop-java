/**
 * 
 * This file was automatically generated by the Repast Simphony Agent Editor.
 * Please see http://repast.sourceforge.net/ for details.
 * 
 */

/**
 *
 * Set the package name.
 *
 */
package suddenStop;

import static java.lang.Math.*;
import static repast.simphony.essentials.RepastEssentials.*;
import repast.simphony.context.Context;

/**
 * 
 * This is an agent.
 * 
 */
public class Firm {

	public static SupplyManager supplyManager;

	private class FirmState implements Cloneable {
		private double born = 0.0;
		private double expon = 0.0;
		private double acumQ = 0.0;
		private double firstUnitCost = 0.0;
		private double performance = 0.0;
		private double capital = 0.0;
		private double capitalProductivity = 0.0;
		private double rDEfficiency = 0.0;
		private double costOfCapital = 0.0;
		private double fixedCost = 0.0;
		private double acumProfit = 0.0;

		@Override
		protected FirmState clone() {
			try {
				return (FirmState) super.clone();
			} catch (CloneNotSupportedException e) {
				e.printStackTrace();
			}
			return null;
		}

	}

	private FirmState currentState, nextState;

	private class Decision implements Cloneable {
		private double quantity = 0.0;
		private double rD = 0.0;

		@Override
		protected Decision clone() {
			try {
				return (Decision) super.clone();
			} catch (CloneNotSupportedException e) {
				e.printStackTrace();
			}
			return null;
		}
	}

	private Decision currentDecision, nextDecision;

	protected static long agentIDCounter = 1;
	protected String agentID = "Firm " + (agentIDCounter++);

	public Firm(Context<Object> context) {

		context.add(this);

		nextState = new FirmState();

		nextState.born = GetTickCount();

		// A minimum FUC is set to 10% of mean
		nextState.firstUnitCost = max(
				0.1 * (Double) GetParameter("firstUnitCostMean"),
				supplyManager.firstUnitCostNormal.nextDouble());
		nextState.capitalProductivity = (Double) GetParameter("capitalProductivity");

		nextState.capital = max((Double) GetParameter("minimumCapital"),
				supplyManager.iniKNormal.nextDouble());

		// 0.5 < learning rate <= 1.0
		double learningRate = min(1.0,
				max(supplyManager.learningRateDistrib.nextDouble(), 0.51));
		nextState.expon = log(learningRate) / log(2.0);
		nextState.rDEfficiency = max(0.0,
				supplyManager.rDEfficiencyNormal.nextDouble());

		nextState.costOfCapital = (Double) GetParameter("costOfCapital");
		nextState.fixedCost = (Double) GetParameter("fixedCost");
		nextState.performance = (Double) GetParameter("initialPerformance");

		currentState = nextState.clone();
		
		// Sets next decision
		nextDecision = new Decision();

		nextDecision.rD = 0.0;
		nextDecision.quantity = nextState.capital
				* nextState.capitalProductivity;

	}

	public double offer() {

		currentState = nextState.clone();
		currentDecision = nextDecision.clone();

		return currentDecision.quantity;

	}

	/**
	 * 
	 * Process demand respond and returns false if firm exits the industry,
	 * otherwise returns true
	 * 
	 * @method processDemandResponse
	 * 
	 */
	public boolean processDemandResponse() {

		// Calculates profit & Performance
		double profit = calcProfit(currentState, currentDecision,
				supplyManager.price);

		currentState.performance = (Double) GetParameter("performanceWeight")
				* currentState.performance
				+ (1 - (Double) GetParameter("performanceWeight")) * profit
				/ currentState.capital;

		// accumulates Q & profit
		currentState.acumQ += currentDecision.quantity;
		currentState.acumProfit += profit;

		// if it is an exit, returns false
		return !(currentState.performance < (Double) GetParameter("minimumPerformance") || currentState.capital < (Double) GetParameter("minimumCapital"));

	}

	public void plan() {

		double maxFunding = calcProfit(currentState, currentDecision,
				supplyManager.price)
				+ (Double) GetParameter("depreciation")
				* currentState.capital
				+ ((Demand.getSSMagnitude() > 0.0) ? 0.0
						: ((Double) GetParameter("maxExternalFunding") * currentState.capital));

		double invest = min(maxFunding, currentState.capital
				* ((Double) GetParameter("depreciation") + calcNetInvestment()));

		invest = max(0.0, invest);

		nextState.capital = currentState.capital
				* (1.0 - (Double) GetParameter("depreciation")) + invest;

		nextDecision.quantity = nextState.capital
				* currentState.capitalProductivity;

		// Then new R&D is determined to optimize First unit cost.The maxFunding
		// is relevant to speed up the process.
		double optimalRD = pow(
				currentState.firstUnitCost
						/ currentState.rDEfficiency
						* (pow(currentState.acumQ + nextDecision.quantity,
								1.0 + currentState.expon) - pow(
								currentState.acumQ, 1.0 + currentState.expon)),
				0.5) - 1.0;

		double minRD = 1.0 / currentState.rDEfficiency - 1.0;

		nextDecision.rD = max(minRD, min(maxFunding - invest, optimalRD));

		// apply innovation
		nextState.firstUnitCost = currentState.firstUnitCost * 1.0
				/ ((nextDecision.rD + 1.0) * currentState.rDEfficiency)
				* supplyManager.innovationErrorNormal.nextDouble();

	}

	/*
	 * Estimates potential performance for next decision at given price
	 */
	public Double estimatePerformance(double price) {

		return (Double) GetParameter("performanceWeight")
				* currentState.performance
				+ (1 - (Double) GetParameter("performanceWeight"))
				* calcProfit(nextState, nextDecision, price)
				/ nextState.capital;

	}

	private double calcProfit(FirmState state, Decision dec, double price) {

		return price * dec.quantity - calcTotVarCost(state, dec)
				- calcFixedCost(state, dec);

	}

	// Calculates cost using learning curve: cost of new acummulated Q minus
	// old acummulated Q. See http://maaw.info/LearningCurveSummary.htm
	// (Wright model)
	private double calcTotVarCost(FirmState state, Decision dec) {

		return state.firstUnitCost
				* (pow(state.acumQ + dec.quantity, 1.0 + currentState.expon) - pow(
						state.acumQ, 1.0 + currentState.expon));

	}

	private double calcFixedCost(FirmState state, Decision dec) {

		return (state.costOfCapital + (Double) GetParameter("depreciation"))
				* state.capital - dec.rD - state.fixedCost;

	}

	private double calcMarginalCost() {

		return currentState.firstUnitCost
				* (1.0 + currentState.expon)
				* pow(currentState.acumQ + currentDecision.quantity,
						currentState.expon)
				+ (currentState.costOfCapital + (Double) GetParameter("depreciation"))
				/ currentState.capitalProductivity;

	}

	private double calcNetInvestment() {
		double mktSh = currentDecision.quantity / supplyManager.totalQuantity;

		double optimalMarkUp = ((Double) GetParameter("demandElasticity") + (1 - mktSh)
				* (Double) GetParameter("supplyElasticity"))
				/ ((Double) GetParameter("demandElasticity") + (1 - mktSh)
						* (Double) GetParameter("supplyElasticity") - mktSh);

		// dejo Winter a un lado y pongo el máximo igual al mark up del
		// substituto.
		/*
		 * double maxMarkUp = 0.999 (supplyManager.price + (Double)
		 * GetParameter("priceOfSubstitute")) / (2 * marginalCost()); return
		 * (Double) GetParameter("investmentParam") (1 - min(optimalMarkUp,
		 * maxMarkUp) * marginalCost() / supplyManager.price);
		 */
		return (Double) GetParameter("investmentParam")
				* (1 - optimalMarkUp * calcMarginalCost() / supplyManager.price);

	}

	public double getAge() {
		return GetTickCount() - currentState.born;
	}

	public double getMedCost() {
		return (calcTotVarCost(currentState, currentDecision) + calcFixedCost(
				currentState, currentDecision)) / currentDecision.quantity;
	}

	public double getProfit() {
		return calcProfit(currentState, currentDecision, supplyManager.price);
	}

	public double getPrice() {
		return supplyManager.price;
	}

	public double getCapital() {
		return currentState.capital;
	}

	public double getQuantity() {
		return currentDecision.quantity;
	}

	public double getPerformance() {
		return currentState.performance;
	}

	public double getRD() {
		return currentDecision.rD;
	}

	public double getFirstUnitCost() {
		return currentState.firstUnitCost;
	}

	public double getAcumQuantity() {
		return currentState.acumQ;
	}

	public String toString() {
		return this.agentID;
	}

	public double getBorn() {
		return currentState.born;
	}

	public double getExpon() {
		return currentState.expon;
	}

	public double getAcumProfit() {
		return currentState.acumProfit;
	}

}

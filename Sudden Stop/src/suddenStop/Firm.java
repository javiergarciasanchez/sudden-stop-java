/**
 * 
 * This file was automatically generated by the Repast Simphony Agent Editor.
 * Please see http://repast.sourceforge.net/ for details.
 * 
 */

/**
 *
 * Set the package name.
 *
 */
package suddenStop;

import static java.lang.Math.*;
import static repast.simphony.essentials.RepastEssentials.*;

import java.lang.reflect.Field;

import repast.simphony.context.Context;

public class Firm {

	public static SupplyManager supplyManager;
	public static IndependentVarsManager independentVarsManager;

	private FirmState currentState, nextState;

	protected static long agentIDCounter = 1;
	protected String agentID = "Firm " + (agentIDCounter++);

	public Firm(Context<Object> context) {

		context.add(this);

		nextState = new FirmState();

		nextState.quantity = nextState.getCapital()
				* nextState.getCapitalProductivity();

		currentState = nextState.clone();

	}

	public void moveToNextState() {
		currentState = nextState.clone();
	}

	/**
	 * Estimates if nextDecision would be an exit given nextState and price It
	 * works like ProcessResponseToDemand but without changing the current
	 * situation
	 */
	public boolean estimateResponseToDemand(double price) {

		FirmState tmpSt = nextState.clone();

		// updates current profit & performance
		tmpSt.profit = calcProfit(tmpSt, price);
		tmpSt.performance = calcPerformance(tmpSt);

		return !isExit(tmpSt);

	}

	/**
	 * 
	 * Process demand respond and returns false if firm exits the industry,
	 * otherwise returns true
	 * 
	 */
	public void processResponseToDemand(double price) {

		// updates current profit & performance
		double profit = calcProfit(currentState, price);
		currentState.profit = profit;
		currentState.performance = calcPerformance(currentState);

		// updates next state
		nextState.capital = currentState.getCapital()
				* (1 - (Double) GetParameter("depreciation"));
		nextState.acumQ = currentState.getAcumQ() + currentState.getQuantity();

		// Loss increases debt
		nextState.debt += (profit < 0.0) ? -profit : 0.0;
		// Gains increase equity available
		nextState.equityAvailable = (profit > 0.0) ? profit
				: 0.0 + currentState.getExternalEquityAvailable();

		adjustLeverage(nextState);

		// Meet minimum capital
		double minCap = (Double) GetParameter("minimumCapital");
		if (minCap > nextState.getCapital()) {
			getFunds(nextState, minCap - nextState.getCapital());
		}

	}

	public void plan() {

		// it is assumed there is no divesture
		double optInvest = max(0.0,
				getNetInvestment(currentState, supplyManager.price));

		getFunds(nextState, optInvest * nextState.getCapital());
		// It is necessary to reduce cash excess, because profit was acummulated
		// as cash
		reduceCashExcess(nextState);

		nextState.quantity = nextState.getCapital()
				* nextState.capitalProductivity;

		// Then new R&D is determined to optimize First unit cost.The maxFunding
		// is relevant to speed up the process.
		double optRD = pow(
				nextState.firstUnitCost
						/ nextState.rDEfficiency
						* (pow(nextState.acumQ + nextState.quantity,
								1.0 + nextState.expon) - pow(nextState.acumQ,
								1.0 + nextState.expon)), 0.5) - 1.0;

		/*
		 * There is a minimum amount of RD to make FUC decrease
		 */
		nextState.rD = max(1.0 / nextState.rDEfficiency - 1.0, optRD);

		// apply innovation
		nextState.firstUnitCost = nextState.firstUnitCost * 1.0
				/ ((nextState.rD + 1.0) * nextState.rDEfficiency)
				* supplyManager.innovationErrorNormal.nextDouble();

	}

	public boolean isExit() {
		return isExit(currentState);
	}

	private void adjustLeverage(FirmState st) {

		double needs = st.getDebt() - st.getCapital() * st.targetLeverage;

		if (needs > 0.0) {
			// reduce debt by increasing equity
			st.debt -= min(st.getEquityAvailable(), needs);
			st.equityAvailable -= min(st.getEquityAvailable(), needs);

		}
	}

	/*
	 * Looks for funds to increase capital.
	 * 
	 * See Mathematica notebook for the equations getFunds.nb
	 */
	private void getFunds(FirmState st, double funds) {

		double newDebt;
		double newEquity = st.getEquityAvailable();
		double availLeverage = st.targetLeverage * st.capital - st.debt;

		if (Demand.isSS()) {
			// only cash can be used
			newDebt = st.getCash();
		} else {
			newDebt = (availLeverage + newEquity * st.targetLeverage)
					/ (1 - st.targetLeverage);
		}

		if ((newEquity + newDebt) > funds) {
			newDebt = newDebt * funds / (newEquity + newDebt);
			newEquity = funds - newDebt;
		}

		st.debt += newDebt;
		st.capital += newEquity + newDebt;
		st.equityAvailable -= newEquity;

	}

	/*
	 * Reduces cash excess to the required by target leverage
	 */
	private void reduceCashExcess(FirmState st) {
		double cashExcess = st.getCash()
				- max(0.0, st.getCapital() * (-st.targetLeverage));

		if (cashExcess > 0.0) {
			// reduce cash through dividends payment
			st.debt += cashExcess;
		}

	}

	private boolean isExit(FirmState st) {
		/*
		 * Exits happens if: a) perf < cost of Equity b) capital < minimum
		 * capital c) default
		 */
		return ((st.getPerformance() < (Double) GetParameter("costOfEquity"))
				|| (st.getCapital() < (Double) GetParameter("minimumCapital")) || (st
				.getEquity() < 0.0));

	}

	private double calcProfit(FirmState st, double price) {

		return price * st.quantity - getTotVarCost(st) - getFixedCost(st)
				- st.costOfDebt * st.getDebt();

	}

	private double calcPerformance(FirmState st) {
		return (Double) GetParameter("performanceWeight") * st.performance
				+ (1 - (Double) GetParameter("performanceWeight")) * st.profit
				/ st.getEquity();
	}

	// Calculates cost using learning curve: cost of new acummulated Q minus
	// old acummulated Q. See http://maaw.info/LearningCurveSummary.htm
	// (Wright model)
	private double getTotVarCost(FirmState st) {

		return st.firstUnitCost
				* (pow(st.acumQ + st.quantity, 1.0 + currentState.expon) - pow(
						st.acumQ, 1.0 + currentState.expon));

	}

	private double getFixedCost(FirmState st) {

		return (Double) GetParameter("depreciation") * getCapital() + st.rD
				+ st.fixedCost;

	}

	// Maximizes Economic Profit
	private double getNetInvestment(FirmState st, double price) {
		double mktSh = st.quantity / supplyManager.totalQuantity;
		double demElast = (Double) GetParameter("demandElasticity");
		double supElast = (Double) GetParameter("supplyElasticity");

		double marginalCost = st.firstUnitCost * (1.0 + st.expon)
				* pow(st.acumQ + st.quantity, st.expon)
				+ (getWACC(st) + (Double) GetParameter("depreciation"))
				/ st.capitalProductivity;

		double optimalMarkUp = (demElast + (1 - mktSh) * supElast)
				/ (demElast + (1 - mktSh) * supElast - mktSh);

		return (Double) GetParameter("investmentParam")
				* (1 - optimalMarkUp * marginalCost / price);

	}

	private Double getWACC(FirmState st) {
		return st.getCostOfDebt() * st.getLeverage() + st.getCostOfEquity()
				* (1 - st.getLeverage());
	}

	public double getAge() {
		return GetTickCount() - currentState.getBorn();
	}

	// It includes equity cost
	public double getMedCost() {
		return (getTotVarCost(currentState) + getFixedCost(currentState)
				+ getInterest() + currentState.getCostOfEquity()
				* currentState.getEquity())
				/ currentState.getQuantity();
	}

	public double getEBIT() {
		return getProfit() + getInterest();
	}

	public double getROA() {
		return getEBIT() / getAssets();
	}

	public double getRONA() {
		return getEBIT() / getCapital();
	}

	public double getInterest() {
		return currentState.getDebt() * currentState.getCostOfDebt();
	}

	public double getProfit() {
		return currentState.getProfit();
	}

	public double getROE() {
		return getProfit() / getEquity();
	}

	public double getPrice() {
		return supplyManager.price;
	}

	public double getCapital() {
		return currentState.getCapital();
	}

	public double getCash() {
		return currentState.getCash();
	}

	public double getAssets() {
		return currentState.getAssets();
	}

	public double getDebt() {
		return currentState.getDebt();
	}

	public double getLeverage() {
		return currentState.getLeverage();
	}

	public double getEquity() {
		return currentState.getEquity();
	}

	public double getPerformance() {
		return currentState.getPerformance();
	}

	public double getFirstUnitCost() {
		return currentState.getFirstUnitCost();
	}

	public double getAcumQuantity() {
		return currentState.getAcumQ();
	}

	public double getRD() {
		return currentState.getRD();
	}

	public double getTargetLeverage() {
		return currentState.getTargetLeverage();
	}

	public double getQuantity() {
		return currentState.getQuantity();
	}

	public String toString() {
		return this.agentID;
	}

	public double getBorn() {
		return currentState.born;
	}

	public double getExpon() {
		return currentState.expon;
	}

	public int getFUCCohort() {
		return getCohort(currentState.firstUnitCost,
				independentVarsManager.getFirstUnitCostLimit());
	}

	public int getRDEfCohort() {
		return getCohort(currentState.rDEfficiency,
				independentVarsManager.getRDEfficiencyLimit());
	}

	public int getLevCohort() {
		return getCohort(currentState.targetLeverage,
				independentVarsManager.getLeverageLimit());
	}

	public int getEquityCohort() {
		return getCohort(currentState.targetLeverage,
				independentVarsManager.getEquityAccessLimit());
	}

	public int getLRCohort() {
		return getCohort(exp(currentState.expon * log(2.0)),
				independentVarsManager.getLearningRateLimit());
	}

	public int getTimeCohort() {
		return getCohort(currentState.born,
				independentVarsManager.getTimeCohortLimit());
	}

	private int getCohort(double fVal, double[] lim) {

		for (int i = 0; i < independentVarsManager.cohorts - 1; i++) {
			if (fVal < lim[i])
				return i + 1;
		}

		return independentVarsManager.cohorts;

	}

	public double get(String var) {
		Field f = null;
		try {
			f = Class.forName("suddenStop.FirmState").getDeclaredField(var);
		} catch (Throwable e) {
			e.printStackTrace();
			System.exit(-1);
		}

		try {
			return f.getDouble(this.currentState);
		} catch (Throwable e) {
			e.printStackTrace();
			System.exit(-1);
		}
		return 0;

	}

	public double getROELRTime(int lRCoh, int timeCoh) {
		if (getLRCohort() == lRCoh && getTimeCohort() == timeCoh) {
			return getProfit() / getEquity();
		} else {
			return 0.0;
		}
	}

	public double getROALRTime(int lRCoh, int timeCoh) {
		if (getLRCohort() == lRCoh && getTimeCohort() == timeCoh) {
			return getEBIT() / getAssets();
		} else {
			return 0.0;
		}
	}

	public double getQuantityLRTime(int lRCoh, int timeCoh) {
		if (getLRCohort() == lRCoh && getTimeCohort() == timeCoh) {
			return getEBIT() / getAssets();
		} else {
			return 0.0;
		}
	}
}

/**
 * 
 * This file was automatically generated by the Repast Simphony Agent Editor.
 * Please see http://repast.sourceforge.net/ for details.
 * 
 */

/**
 *
 * Set the package name.
 *
 */
package suddenStop;

import static java.lang.Math.max;
import static java.lang.Math.min;
import static java.lang.Math.pow;
import static repast.simphony.essentials.RepastEssentials.GetParameter;
import static repast.simphony.essentials.RepastEssentials.GetTickCount;
import static suddenStop.CashUsage.CASH;
import static suddenStop.CashUsage.LEVERAGE;

import java.lang.reflect.Field;

import repast.simphony.context.Context;

public class Firm {

	public static SupplyManager supplyManager;
	public static IndependentVarsManager independentVarsManager;

	private FirmState currentState, nextState;
	private boolean toBeKilled = false;

	protected static long agentIDCounter = 1;
	protected long agentIntID = agentIDCounter++;
	protected String agentID = "Firm " + agentIntID;

	public Firm(Context<Object> context) {

		context.add(this);

		nextState = new FirmState();

		nextState.quantity = nextState.getCapital()
				* nextState.getCapitalProductivity();

		currentState = nextState.clone();
	
	}

	public void moveToNextState() {

		// apply innovation
		nextState.firstUnitCost = nextState.firstUnitCost
				/ ((nextState.rD + 1.0) * nextState.rDEfficiency)
				* supplyManager.innovationErrorNormal.nextDouble();

		// Define quantity offered
		nextState.quantity = nextState.getCapital()
				* nextState.capitalProductivity;

		nextState.externalEquityAvailable = currentState
				.resetExternalEquityAvailable();

		currentState = nextState.clone();

	}

	/**
	 * Estimates if nextDecision would be an exit given nextState and price It
	 * works like ProcessResponseToDemand but without changing the current
	 * situation
	 */
	public boolean estimateResponseToDemand(double price) {

		FirmState tmpSt = nextState.clone();

		return processProfit(tmpSt, price);

	}

	/**
	 * 
	 * Process demand respond and returns false if firm exits the industry,
	 * otherwise returns true
	 * 
	 */
	public void processResponseToDemand(double price) {

		if (toBeKilled = !processProfit(currentState, price)) {
			return;
		}

		// From here onward all modifications are done in nextState
		nextState = currentState.clone();

		acumulateVariables();

		if (toBeKilled = !adjustCapital(price)) {
			return;
		}

		selectRD();

	}

	private boolean processProfit(FirmState st, double price) {

		double profit = calcProfit(st, price);

		st.profit = profit;

		/*
		 * Funds Generated by Operations (fgo) could be < 0 meaning that profit
		 * is lower than depreciation
		 */
		double fgo = profit + st.getDepreciation();

		// Raise funds to cover negative fgo
		if (fgo < 0) {
			/*
			 * Raise funds will add -fgo to capital, so to keep capital
			 * unaffected by loss -fgo should be subtracted before
			 */

			st.capital -= -fgo;
			toBeKilled = (raiseFunds(st, CASH, -fgo) < -fgo);
		} else {
			toBeKilled = (calcPerformance(st) < getMinimumPerformance(st));
		}

		return !toBeKilled;

	}

	private double getMinimumPerformance(FirmState st) {
		return st.getWACC();
	}

	private double calcProfit(FirmState st, double price) {

		return price * st.getQuantity() - st.getTotVarCost()
				- st.getTotFixedCost() - st.getInterest();

	}

	private double calcPerformance(FirmState st) {
		return (Double) GetParameter("performanceWeight") * st.getPerformance()
				+ (1 - (Double) GetParameter("performanceWeight"))
				* st.getRONA();
	}

	private void acumulateVariables() {

		nextState.performance = calcPerformance(currentState);
		nextState.acumQ = currentState.getAcumQ() + currentState.getQuantity();

	}

	private boolean adjustCapital(double price) {

		// Applies depreciation
		nextState.capital = currentState.getCapital()
				- currentState.getDepreciation();

		// Meet minimum capital
		double minimalNeeds = (Double) GetParameter("minimumCapital")
				- nextState.getCapital();
		if (minimalNeeds > 0) {
			toBeKilled = (raiseFunds(nextState, CASH, minimalNeeds) < minimalNeeds);
		}

		raiseFunds(nextState, LEVERAGE, getNetInvestment(currentState, price));

		return !toBeKilled;

	}

	private double raiseFunds(FirmState st, CashUsage cashUsage, double funds) {

		double fgoUsed = st.getAvailableFundsFromOperations();
		double externalEquityUsed = +st.getExternalEquityAvailable();

		double debtUsed = st.getDebtAvailableByNewEquity(fgoUsed
				+ externalEquityUsed, cashUsage);

		// Uses pecking order
		if (fgoUsed + debtUsed + externalEquityUsed > funds) {
			fgoUsed = min(fgoUsed, funds);
			debtUsed = min(st.getDebtAvailableByNewCapital(funds, cashUsage),
					funds - fgoUsed);
			externalEquityUsed = funds - debtUsed - fgoUsed;
		}

		st.debt += debtUsed;
		st.capital += (fgoUsed + externalEquityUsed + debtUsed);
		st.availableFundsFromOperations -= fgoUsed;
		st.externalEquityAvailable -= externalEquityUsed;

		return fgoUsed + externalEquityUsed + debtUsed;

	}

	/*
	 * Maximizes Economic Profit Returns the increment suggested It is >= than
	 * zero
	 */
	private double getNetInvestment(FirmState st, double price) {

		double mktSh = st.getQuantity() / supplyManager.totalQuantity;
		double demElast = (Double) GetParameter("demandElasticity");
		double supElast = (Double) GetParameter("supplyElasticity");
		double optCapIncr;

		double marginalCost = st.getFirstUnitCost()
				* (1.0 + st.getLRExpon())
				* pow(st.getAcumQ() + st.getQuantity(), st.getLRExpon())
				+ (st.getWACC() + (Double) GetParameter("depreciation") + (Double) GetParameter("structuralCost"))
				/ st.getCapitalProductivity();

		double optimalMarkUp = (demElast + (1 - mktSh) * supElast)
				/ (demElast + (1 - mktSh) * supElast - mktSh);

		optCapIncr = (Double) GetParameter("investmentParam")
				* (1 - optimalMarkUp * marginalCost / price);

		return max(0.0, optCapIncr * st.getCapital());

	}

	private void selectRD() {

		// Then new R&D is determined to optimize First unit cost.The maxFunding
		// is relevant to speed up the process.
		double optRD = pow(
				nextState.firstUnitCost
						/ nextState.rDEfficiency
						* (pow(nextState.acumQ + nextState.quantity,
								1.0 + nextState.getLRExpon()) - pow(
								nextState.acumQ, 1.0 + nextState.getLRExpon())),
				0.5) - 1.0;

		/*
		 * There is a minimum amount of RD to make FUC decrease
		 */
		nextState.rD = max(1.0 / nextState.rDEfficiency - 1.0, optRD);

	}

	public boolean isToBeKilled() {
		return toBeKilled;
	}

	public boolean willSurvive() {
		return !toBeKilled;
	}

	public double getWACC() {
		return currentState.getWACC();
	}

	public double getAge() {
		return GetTickCount() - currentState.getBorn();
	}

	// It includes equity cost
	public double getMedCost() {
		return currentState.getMedCost();
	}

	public double getEBIT() {
		return currentState.getEBIT();
	}

	public double getEBITDA() {
		return currentState.getEBITDA();
	}

	public double getInterest() {
		return currentState.getInterest();
	}

	public double getExpectedEquityRetribution() {
		return currentState.getExpectedEquityRetribution();
	}

	public double getTotFixedCost() {
		return currentState.getTotFixedCost();
	}

	public double getTotVarCost() {
		return currentState.getTotVarCost();
	}

	public double getROE() {
		return currentState.getROE();
	}

	public double getROA() {
		return currentState.getROA();
	}

	public double getRONA() {
		return currentState.getRONA();
	}

	public double getProfit() {
		return currentState.getProfit();
	}

	public double getPrice() {
		return supplyManager.price;
	}

	public double getCapital() {
		return currentState.getCapital();
	}

	public double getCash() {
		return currentState.getCash();
	}

	public double getAssets() {
		return currentState.getAssets();
	}

	public double getDebt() {
		return currentState.getDebt();
	}

	public double getNetDebt() {
		return currentState.getNetDebt();
	}

	public double getLeverage() {
		return currentState.getLeverage();
	}

	public double getNetLeverage() {
		return currentState.getNetLeverage();
	}

	public double getEquity() {
		return currentState.getEquity();
	}

	public double getPerformance() {
		return currentState.getPerformance();
	}

	public double getDepreciation() {
		return currentState.getDepreciation();
	}

	public double getFirstUnitCost() {
		return currentState.getFirstUnitCost();
	}

	public double getQuantity() {
		return currentState.getQuantity();
	}

	public double getMktShare() {
		return currentState.getQuantity() / supplyManager.totalQuantity;
	}

	public double getAcumQ() {
		return currentState.getAcumQ();
	}

	public double getRD() {
		return currentState.getRD();
	}

	public double getInitialFUC() {
		return currentState.getInitialFUC();
	}

	public double getRDEfficiency() {
		return currentState.getRDEfficiency();
	}

	public double getTargetLeverage() {
		return currentState.getTargetLeverage();
	}

	public double getMaxExternalEquity() {
		return currentState.getMaxExternalEquity();
	}

	public double getLearningRate() {
		return currentState.getLearningRate();
	}

	public double getStructuralCost() {
		return currentState.getStructuralCost();
	}
	public double getFixedCost(){
		return currentState.getFixedCost();
	}
	public double getBorn() {
		return currentState.getBorn();
	}

	public String toString() {
		return this.agentID;
	}

	public int getFUCCohort() {
		return getCohort(currentState.getInitialFUC(),
				independentVarsManager.getFirstUnitCostLimit());
	}

	public int getRDEfCohort() {
		return getCohort(currentState.getRDEfficiency(),
				independentVarsManager.getRDEfficiencyLimit());
	}

	public int getLevCohort() {
		return getCohort(currentState.getTargetLeverage(),
				independentVarsManager.getLeverageLimit());
	}

	public int getEquityCohort() {
		return getCohort(currentState.getMaxExternalEquity(),
				independentVarsManager.getEquityAccessLimit());
	}

	public int getLRCohort() {
		return getCohort(currentState.getLearningRate(),
				independentVarsManager.getLearningRateLimit());
	}

	public int getTimeCohort() {
		return getCohort(currentState.getBorn(),
				independentVarsManager.getTimeCohortLimit());
	}

	private int getCohort(double fVal, double[] lim) {

		for (int i = 0; i < independentVarsManager.cohorts - 1; i++) {
			if (fVal < lim[i])
				return i + 1;
		}

		return independentVarsManager.cohorts;

	}

	public double get(String var) {
		Field f = null;
		try {
			f = Class.forName("suddenStop.FirmState").getDeclaredField(var);
		} catch (Throwable e) {
			e.printStackTrace();
			System.exit(-1);
		}

		try {
			return f.getDouble(this.currentState);
		} catch (Throwable e) {
			e.printStackTrace();
			System.exit(-1);
		}
		return 0;

	}

	public double getROELRTime(int lRCoh, int timeCoh) {
		if (getLRCohort() == lRCoh && getTimeCohort() == timeCoh) {
			return getProfit() / getEquity();
		} else {
			return 0.0;
		}
	}

	public double getROALRTime(int lRCoh, int timeCoh) {
		if (getLRCohort() == lRCoh && getTimeCohort() == timeCoh) {
			return getEBIT() / getAssets();
		} else {
			return 0.0;
		}
	}

	public double getQuantityLRTime(int lRCoh, int timeCoh) {
		if (getLRCohort() == lRCoh && getTimeCohort() == timeCoh) {
			return getEBIT() / getAssets();
		} else {
			return 0.0;
		}
	}

}
